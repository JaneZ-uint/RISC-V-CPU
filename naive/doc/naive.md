# Naive RISC-V CPU 文档

## 项目概述

本项目实现了一个简单的五级流水线 RISC-V CPU (`naive_cpu`)。它支持 RV32I 指令集的一个子集，包括算术逻辑运算、内存访问（Load/Store）和分支跳转指令。

### 主要特性

*   **架构**: 经典的五级流水线 (IF, ID, EX, MEM, WB)。
*   **指令集**: RV32I 子集。
*   **冲突处理**:
    *   **数据冲突 (RAW)**: 采用暂停 (Stall) 机制。ID 阶段检测到源寄存器与 EX 或 MEM 阶段的目标寄存器冲突时，会请求流水线暂停。WB 阶段的数据冲突通过寄存器堆内部的前递 (Internal Forwarding) 解决。
    *   **控制冲突 (Branch)**: 采用“静态预测不跳转”策略。在 EX 阶段计算出分支跳转发生时，会冲刷 (Flush) IF/ID 和 ID/EX 流水线寄存器，并更新 PC 为跳转目标地址。

## 模块详细说明

### 1. 顶层模块与定义

*   **`naive_cpu.v`**: CPU 的顶层模块。负责实例化各个流水线阶段、流水线寄存器、控制器和寄存器堆，并将它们连接起来。它还暴露了指令存储器和数据存储器的接口。
*   **`defines.v`**: 包含全局宏定义，如指令操作码 (Opcodes)、ALU 操作码、总线宽度定义等。

### 2. 取指阶段 (IF - Instruction Fetch)

*   **`pc_reg.v`**: 程序计数器 (PC) 寄存器。
    *   在每个时钟上升沿更新 PC。
    *   支持暂停 (`stall`)：保持当前 PC 值不变。
    *   支持分支跳转 (`branch_flag`)：当分支发生时，将 PC 更新为跳转目标地址。
    *   默认行为：`pc <= pc + 4`。
*   **`if_stage.v`**: 取指阶段逻辑。
    *   主要作为一个直通模块，将 PC 传递给指令存储器接口，并将取到的指令传递给下一级。

### 3. 译码阶段 (ID - Instruction Decode)

*   **`if_id_reg.v`**: IF/ID 流水线寄存器。
    *   暂存 IF 阶段传递下来的 PC 和指令。
    *   支持暂停 (`stall`) 和冲刷 (`flush`)。
*   **`id_stage.v`**: 译码阶段逻辑。
    *   **指令解码**: 根据指令的 Opcode 和 Funct3/Funct7 字段，解析出 ALU 操作码 (`aluop`)、源寄存器地址、目标寄存器地址、立即数等。
    *   **操作数准备**: 读取寄存器堆 (`regfile`) 获取源操作数。
    *   **冲突检测**: 检查当前指令需要的源寄存器是否正在被 EX 或 MEM 阶段的指令写入。如果是，则发出暂停请求 (`stall_req`)。
*   **`regfile.v`**: 通用寄存器堆。
    *   包含 32 个 32 位寄存器 (x0-x31)。
    *   支持双端口读和单端口写。
    *   **内部前递**: 如果读地址与当前写地址相同（且写使能有效），直接将写数据输出到读端口，解决 WB 阶段的数据相关。

### 4. 执行阶段 (EX - Execution)

*   **`id_ex_reg.v`**: ID/EX 流水线寄存器。
    *   暂存 ID 阶段解码出的控制信号和操作数。
    *   支持暂停和冲刷（用于分支跳转时的流水线清除）。
*   **`ex_stage.v`**: 执行阶段逻辑。
    *   **ALU 运算**: 根据 `aluop` 对操作数进行算术或逻辑运算（如 ADD, SUB, SLL, SLT, XOR, OR, AND 等）。
    *   **分支判断**: 对于分支指令 (Branch)，比较两个操作数并决定是否跳转。
    *   **地址计算**: 对于 Load/Store 指令，计算内存访问地址。
    *   **跳转处理**: 如果是 JAL/JALR 或满足条件的分支指令，输出 `branch_flag` 和跳转目标地址。

### 5. 访存阶段 (MEM - Memory Access)

*   **`ex_mem_reg.v`**: EX/MEM 流水线寄存器。
    *   暂存 EX 阶段的运算结果（或内存地址）和目标寄存器信息。
*   **`mem_stage.v`**: 访存阶段逻辑。
    *   **Load 操作**: 根据地址低 2 位和指令类型 (LB, LH, LW, LBU, LHU)，从读取到的 32 位内存数据中提取并扩展所需的字节或半字。
    *   **Store 操作**: 根据地址低 2 位和指令类型 (SB, SH, SW)，生成正确的写数据和字节选择信号 (`mem_sel`)。
    *   对于非访存指令，直接将 EX 阶段的运算结果传递给下一级。

### 6. 写回阶段 (WB - Write Back)

*   **`mem_wb_reg.v`**: MEM/WB 流水线寄存器。
    *   暂存最终要写入寄存器堆的数据和目标寄存器地址。
    *   其输出直接连接到 `regfile` 的写端口。

### 7. 控制单元

*   **`ctrl.v`**: 全局控制模块。
    *   接收来自 ID 阶段的暂停请求 (`stall_req_id`) 和来自 EX 阶段的分支标志 (`branch_flag`)。
    *   **暂停控制**: 当发生 Load-Use 冲突时，暂停 PC 和 IF/ID 阶段，并冲刷 ID/EX 阶段（插入气泡）。
    *   **冲刷控制**: 当发生分支跳转时，冲刷 IF/ID 和 ID/EX 阶段，丢弃错误路径上的指令。
