# Tomasulo CPU 架构设计

本文档详细介绍了基于 Tomasulo 算法的乱序执行 RISC-V CPU 的设计方案。

## 1. 总体架构 / 概述

本 CPU 采用 **Tomasulo** 动态调度算法以支持乱序执行 (OoO)。它利用 **重排序缓冲区 (ROB)** 和 **寄存器别名表 (RAT)** 实现了寄存器重命名机制，从而解决数据相关性并处理精确异常（特别是分支预测失败的情况）。

流水线包含以下逻辑阶段：
1.  **取指 (Fetch/IF)**
2.  **发射/译码 (Issue/ID)**
3.  **执行 (Execute/EX)** (分布在各个保留站中)
4.  **写回 (Write Back/WB)** (通过公用数据总线广播)
5.  **提交 (Commit/Retire)**

### 核心组件
*   **指令队列 (IQ)**: 解耦取指和发射阶段。
*   **保留站 (RS)**: 算术/逻辑操作的缓冲区，等待操作数就绪。
*   **加载/存储缓冲区 (LSB)**: 内存操作的缓冲区。
*   **重排序缓冲区 (ROB)**: 确保按序提交并处理寄存器重命名。
*   **寄存器文件 (ARF)**: 保存架构状态（真实寄存器值）。
*   **寄存器别名表 (RAT)**: 将架构寄存器映射到 ROB 条目（推测状态）。
*   **公用数据总线 (CDB)**: 广播执行结果。

---

## 2. 流水线阶段详细设计

### 2.1. 指令取指 (IF) & 预译码
*   **目标**: 从统一内存中取出指令并管理程序计数器 (PC)。
*   **组件**:
    *   **PC 寄存器**: 当前指令地址。
    *   **分支预测器 (BPU)**:简单的静态预测（预测不跳转）或 1位/2位 动态预测器。
*   **操作流程**:
    1.  根据 `PC` 从内存读取指令。
    2.  将指令推入 **指令队列 (IQ)**。
    3.  **下一 PC 逻辑**:
        *   如果指令队列满，流水线暂停 (Stall)。
        *   否则，更新 `PC = PC + 4` (如果预测跳转，则更新为预测目标地址)。

### 2.2. 发射 & 译码 (ID)
*   **目标**: 译码指令，重命名寄存器，并将指令分派到保留站。
*   **逻辑 (顺序执行)**:
    1.  从指令队列 (IQ) **Pop** 一条指令。
    2.  **译码**: 解析 opcode/funct 字段以确定指令类型 (ALU, Load, Store, Branch, Jump)。
    3.  **检查结构冒险** (Structural Stall):
        *   **ROB** 是否有空闲条目？
        *   对应的 **RS** (ALU指令) 或 **LSB** (内存指令) 是否有空闲条目？
        *   如果没有，**暂停 (Stall)** 发射阶段。
    4.  **寄存器重命名 (读取操作数)**:
        *   对于每个源寄存器 (`rs1`, `rs2`):
            *   检查 **RAT**: `rs` 是否指向一个 ROB 条目？
            *   **是**: 检查该 ROB 条目。
                *   如果值已就绪 (Ready): 读取 `Value`。
                *   如果值未就绪: 读取 `ROB_ID` (Tag)。
            *   **否** (RAT 指向 ARF): 从 **寄存器文件 (RegFile)** 读取值。
    5.  **分配 (Allocation)**:
        *   分配一个 **ROB 条目** (尾指针)。存储 `指令类型`, `目的寄存器`, 和 `预测 PC` (分支指令用)。
        *   更新 **RAT**: 设置 `RAT[rd] = ROB_ID` (如果该指令写入寄存器)。
    6.  **分派 (Dispatch)**:
        *   将 操作码 + 操作数 (数值 或 Tag) + ROB_ID 发送到选定的 **保留站 (RS)** 或 **LSB**。

### 2.3. 执行 (EX)
*   **目标**: 等待操作数就绪并执行。
*   **保留站 (RS)**:
    *   每个 RS 条目包含: `Busy`, `Op`, `Vj` (源1值), `Vk` (源2值), `Qj` (源1 Tag), `Qk` (源2 Tag), `Dest` (ROB ID), `Imm`。
    *   **监听 CDB (Snoop)**: 持续监听 CDB。如果 `Qj` 或 `Qk` 匹配广播的 Tag，则捕获该值并清除依赖。
    *   **就绪 (Ready)**: 当 `Qj` 和 `Qk` 都为空 (操作数均就绪) 时，置起 `Ready` 信号。
*   **功能单元**:
    *   **ALU 单元**: 执行加减、逻辑、移位等运算。
    *   **分支单元**: 计算分支目标地址和比较结果。
*   **加载/存储单元 (LSU)**:
    *   **地址计算**: 计算有效地址 `base + offset`。
    *   **Load**:如果没有更早的未提交 Store 指令写入同一地址 (地址消歧)，则读取内存。
    *   **Store**:将地址和值写入 ROB (实际内存写入发生在提交阶段)。

### 2.4. 写回 (WB) / CDB 广播
*   **目标**: 将结果发布给等待的指令和 ROB。
*   **操作流程**:
    1.  功能单元请求 **CDB** 总线权限。
    2.  **广播**: 将 `(ROB_ID, Result_Value)` 放到总线上。
    3.  **更新**:
        *   **RS/LSB**: 所有等待该 Tag 的保留站捕获数据。
        *   **ROB**: 对应的 ROB 条目标记为 "Complete" (完成) 并存储结果。

### 2.5. 提交 (Commit/Retire)
*   **目标**: 按程序顺序更新架构状态并处理异常。
*   **操作流程** (仅检查 ROB 的 **头指针 Head**):
    1.  等待 ROB 头部条目标记为 "Complete"。
    2.  **等待清空** (严格顺序): 每周期提交一条指令 (或多条，如果是超标量设计)。
    3.  **根据指令类型执行动作**:
        *   **寄存器写指令 (ALU/Load)**: 将 `Result` 写入 **ARF[rd]**。
            *   **RAT 更新**: 如果 `RAT[rd]` 仍然指向当前的 ROB_ID，则更新 `RAT[rd]` 指向 ARF (清除别名映射)。
        *   **Store**: 执行对数据内存的实际写入。
        *   **Branch**: 比较 `实际结果` 与 `预测结果`。
            *   **匹配**: 正常提交。
            *   **不匹配 (预测失败)**:
                *   **冲刷 (Flush)**: 清空 ROB, RS, LSB, IQ。
                *   **恢复状态**: 重置 RAT 以匹配 ARF (因为之前所有指令都已提交，ARF 是正确的架构状态)。
                *   **重定向 PC**: 设置 `PC = 正确的目标地址`。
    4.  **释放**: 增加 ROB 头指针。

---

## 3. 模块层级结构

```text
TomasuloCPU
├── PC_Reg (程序计数器)
├── Instruction_Memory (统一内存接口)
├── Fetch_Unit (取指单元)
│   ├── Branch_Predictor (分支预测器)
│   └── Instruction_Queue (指令队列)
├── Issue_Unit (发射单元 - 译码与分派)
│   └── Register_Alias_Table (RAT - 寄存器别名表)
├── Reorder_Buffer (ROB - 重排序缓冲区)
├── Reservation_Stations (RS_ALU, RS_Branch - 保留站)
├── Load_Store_Buffer (LSB - 加载存储缓冲)
├── ALU_Common (通用ALU实例)
├── RegFile (寄存器堆)
└── Common_Data_Bus (CDB - 公用数据总线仲裁)
```

## 4. 关键数据结构

### 重排序缓冲区 (ROB) 条目
| 字段 | 描述 |
| :--- | :--- |
| `Busy` | 条目是否被占用 |
| `Ready` | 执行是否完成，值是否有效 |
| `Op` | 操作类型 (用于提交逻辑) |
| `Dest` | 目的寄存器号 (rd) |
| `Value` | 执行结果 |
| `Addr` | 目标地址 (Store/Branch指令用) |
| `Pred` | 分支预测结果 (Taken/NotTaken) |

### 保留站 (RS) 条目
| 字段 | 描述 |
| :--- | :--- |
| `Busy` |保留站是否被占用 |
| `Op` | 要执行的操作 |
| `Vj` | 源操作数 1 的值 |
| `Qj` | 源操作数 1 的 ROB ID (如需等待) |
| `Vk` | 源操作数 2 的值 |
| `Qk` | 源操作数 2 的 ROB ID (如需等待) |
| `Dest` | 结果写入的 ROB ID (Tag) |
| `Imm` | 立即数 |

## 5. 控制流与冒险处理
*   **分支预测**: 初始版本将采用静态预测（总是预测不跳转）或简单的 1-bit 动态预测。
*   **恢复机制**: 在提交阶段检测到分支预测错误时，触发全局 `flush` 信号，重置所有推测性结构 (RS, LSB) 并恢复 `PC`。
