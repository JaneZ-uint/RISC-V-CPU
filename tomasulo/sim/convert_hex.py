import sys

def convert(input_file, output_file):
    mem = {}
    current_addr = 0
    
    with open(input_file, 'r') as f:
        lines = f.readlines()
        
    for line in lines:
        line = line.strip()
        if not line:
            continue
        if line.startswith('@'):
            # Address in hex bytes
            current_addr = int(line[1:], 16)
        else:
            parts = line.split()
            for part in parts:
                val = int(part, 16)
                mem[current_addr] = val
                current_addr += 1
                
    # Find max address
    if not mem:
        return
    max_addr = max(mem.keys())
    
    # Write to output file in 32-bit words
    # RAM is size 65536 words (256KB) -> max byte addr ~ 262143
    # We output words. word_addr = byte_addr // 4
    
    with open(output_file, 'w') as f:
        # We need to print sequentially for readmemh to load correctly into sequential indices
        # If there are gaps, we must fill them with zeros if we assume readmemh loads from 0
        # However, std readmemh with @addr in file allows jumping.
        # But this file's @addr is BYTE address. Verilog readmemh on a reg [31:0] array interprets @addr as ARRAY INDEX (word address).
        # So we need to convert byte addresses to word addresses.
        
        # Strategy: Reconstruct the full byte array, then chunk into words, and write out.
        # This handles gaps by filling 0s, which is safer.
        
        # Max word index
        max_word_idx = max_addr // 4
        
        for k in range(0, max_word_idx + 1):
            base = k * 4
            b0 = mem.get(base, 0)
            b1 = mem.get(base + 1, 0)
            b2 = mem.get(base + 2, 0)
            b3 = mem.get(base + 3, 0)
            
            # Little Encian: b0 is LSB lines up to 32bit word 
            # In hex file for readmemh, usually we write big endian (human readable) or little endian?
            # inst_rom.data generated by hexdump was: ff010113
            # which matches 13 01 01 ff in bytes (little endian).
            # So we construct the integer and format as hex.
            
            word_val = (b3 << 24) | (b2 << 16) | (b1 << 8) | b0
            f.write(f"{word_val:08x}\n")

convert('../../testcases/basicopt1.data', 'inst_rom.data')
